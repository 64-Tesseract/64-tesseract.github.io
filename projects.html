<!DOCTYPE html>
<html>
    <head>
        <title>64_Tesseract Games</title>
        <link rel="stylesheet" type="text/css" href="styles.css">
        <link rel="shortcut icon" type="image/gif" href="Images/icon.gif">
    </head>
    
    <body>
        <header>
            <h1 class="header-title">64_Tesseract Games</h1>
            <a class="inline headbtn" href="index.html">Home</a>
            <a class="inline headbtn" href="games.html">Games</a>
            <a class="inline headbtn" href="projects.html">[Projects]</a>
        </header>
        
        <section class="section-text">
            <h2>My Smaller Projects</h2>
            <p>I usually program random things for fun, and usually they don't grow to become completed games or tools. If, however, I end up half-completing a project that's cool or useful, I'll put it here!</p>
            
            <br><br>
            <h2>Bash Snake <img src="Images/linux.png" class="os-img"></h2>
            <section class="section-game">
                <div style="flex: 70%;">
                <h3>About</h3>
                    <p>Learning Bash was a bit of an adventure for me - so somehow I ended up coding the classic Snake game for a terminal window in it!
                    <p>This is one of the easier half-completed games to run, due to it being written in an interpreted language. You may open <code>snake_menu.sh</code> for a simple "GUI" settings screen, and when you're ready you can press space to jump into the game!
                    <p>However, Bash isn't terribly efficient when it comes to writing interactive scripts, let alone handling large arrays, so it may slow down a bit.</p>
                </div>
                <div style="flex: 30%;">
                    <h3>Downloads</h3>
                    <p><a target="_blank" href="https://github.com/64-Tesseract/Bash-Snake">Github</a></p>
                    
                    <br>
                    <img src="Images/snake.png" style="max-height: 128px;">
                </div>
            </section>
            
            <br><br>
            <h2>2D Raycaster <img src="Images/linux.png" class="os-img"></h2>
            <section class="section-game">
                <div style="flex: 70%;">
                <h3>About</h3>
                    <p>Inspired by the first FPS games, such as Wolfenstein 3D and Doom, I present: a terminal-based non-euclidean maze exploring simulator, proudly written in C!
                    <p>Players can move a character by holding <b>one</b> of the WASD keys, and turn with J and L. You can venture through character-based hallways looking for poorly-anti-aliased items and getting lost in looping rooms. It's got customizable speeds, a variable FOV between 0 and 360 degrees, and decent wall collision detection. The screen even has a fancy head bob!
                    <p>Of course, it's not perfect - what could you expect from my second C project? The rendering can flicker sometimes, whether it's from the rendering thread being slow or rays moving through portals weirdly; and it's a pain to use, since maps are read from <code>.txt</code> files and <code>ncurses</code> isn't good with keyboard presses... but for a proof-of-concept, it's a pretty cool gimmick, I think.</p>
                </div>
                <div style="flex: 30%;">
                    <h3>Downloads</h3>
                    <p><a target="_blank" href="https://github.com/64-Tesseract/2D-Raycaster">Github</a></p>
                    
                    <br>
                    <img src="Images/raycaster.png" style="max-height: 128px;">
                </div>
            </section>
            
            <br><br>
            <h2>Computers I made in The Powder Toy <img src="Images/windows.png" class="os-img"><img src="Images/linux.png" class="os-img"><img src="Images/mac.png" class="os-img"><img src="Images/android.png" class="os-img"></h2>
            <section class="section-game">
                <div style="flex: 70%;">
                <h3><del>Life Story</del> Description</h3>
                    <p><a target="_blank" href="https://powdertoy.co.uk">The Powder Toy</a> is the legendary sandbox game in which players can create all sorts of things, from nukes, to cities, to Turing-complete computers. I myself have dabbled in creating a few (barely) functional computers, and though it's not a "programming" project in the traditional sense, I still decided to include it on this page because they're projects I'm proud of.
                    <p>Electronics in TPT follow a set of simple rules; a spark may travel through metal, one type of silicon can't conduct to another type, gold can conduct faster than other metals, and so on. Realizing I knew how to use most of these mechanics, I decided to challenge myself to create a system that processes numbers in the simplest way I could think of.
                    <p>Thus was born the <a target="_blank" href="https://en.wikipedia.org/wiki/Brainfuck">Brainf***</a> Interpreter - using large piston cells to keep track of numbers and a flying machine to move between them, this computer could handle inputs, outputs, addition and subtraction (by 1), and nested loops. It had many issues, such as the horribly slow speed with everything it did and amazingly poor accuracy when outputting simple numbers.
                    <p>In addition to being able to conduct sparks through metal, TPT also has a mechanic in which raw binary data (up to 30 bits) may be transmitted and manipulated by using filters and ray emitters. Not long after learning about this system, I decided to revisit my previous project and create a computer <i>not</i> based off a deliberately awful language; after a month or so, I ended up with a huge, poorly organized mess of lines that could add numbers and perform binary operations. In addition to all these new features, this computer had a larger & compact storage system, plus a longer tape for the program to sit on. It was still slow, and it had a very unorthodox programming language, but it was a sure improvement.
                    <p>At this stage, I have created one more computer. This one didn't take up the bottom half of the simulation window (only a sixth or so in the corner), was a bit faster and was more efficient. However, being based off a theoretical single-code CPU instruction set, it lacked any bit operations besides subtracting. Also, while this computer had double the memory space the previous one did, the program is stored in the same system, meaning it can be overwritten or modified and with specific inputs one could theoretically inject code.
                    <p>For my last 2 computers, I have also written a "machine-code" compiler in LUA that automatically places filter pixels as needed. After having created these, the next step for me to take is to create a computer with recent "subframe" technology, which exploits the update order of pixels to create incredibly fast mechanisms.</p>
                </div>
                <div style="flex: 30%;">
                    <h3>Game Saves</h3>
                    <p><a target="_blank" href="https://powdertoy.co.uk/Browse/View.html?ID=2487994">Brainf*** Interpreter</a>
                    <p><a target="_blank" href="https://powdertoy.co.uk/Browse/View.html?ID=2601751">Poorly Organized FILT Computer</a>
                    <p><a target="_blank" href="https://powdertoy.co.uk/Browse/View.html?ID=2714304">Quad-Instruction FILT Computer</a></p>
                    
                    <br>
                    <img src="Images/tpt0.png" style="max-height: 128px;">
                    <img src="Images/tpt1.png" style="max-height: 128px;">
                    <img src="Images/tpt2.png" style="max-height: 128px;">
                </div>
            </section>
        </section>
        <br>
    </body>
</html>